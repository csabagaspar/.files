reactjs


###############################################################################################################################
# properties

## initial state
   • es6, in constructor use this.state=...
## this.state

* setState
	* is private to the component and can be changed by callingÂ this.setState(). When the state updates, the component re-renders itself.
   • ha csal az egyik tulajdonsagat updatelem a state-nek akkor a tobbi nem valtozik
* immutable
	* setState eseten csak imutable operatorokat hasznalunk, ha az elozobol kell kiindulni

## this.props

   * are immutable
* propTypes
* defaultProps
* children

## mixins in es5 / higher order component in es6


## statics

## refs
 • controlled input : <input type="text" ref={input => this._name = input} />
  and pull it if needed: handleSubmitClick = () => {
    const name = this._name.value;
    // do something with `name`
  }
  • controlled:
     ◦ react way: store in state: <input
          type="text"
          value={this.state.name}
          onChange={this.handleNameChange}
        />

## this binding
   •ha van egy event handling, akkor kell a bind
   •handler pass argument with bind

   * do it in constructor in ES6 syntax
      • this.handleAction = this.handleAction.bind(this)
   * in Class sintax?
## event handling(classon kivul kesz a scopja)
      <button onClick = {this.handleAction.bind(this)}> Add </button>

## chilren component
   access child component, refs

## render
   * use null for do nothing or render nothing


###############################################################################################################################
# lifecycle

## shouldComponentUpdate(nextProps, nextState)
• ha egy listaban komponensek vannak, és az egyiket megvaltoztatom (szulo state, valtoztatas) akkor mindegyik a listaban ujrarenderelodik
de ha ezt hasznalom akkot annak a renderje nem fut ujra, ha nem valtozott a state
• minimal logika kell ide hogy ne legyen koltsegesebb mint a render()

## componentDidUpdate

* lefoto function update utan pl: a fokuszt rarakom egy adott elemre
	* this.refs.details.getDOMNode().focus();


###############################################################################################################################

# component types

## functional stateless component

* no return as needed
	* oneliner with () ——>  let MyCom = props => ()
* pass props as argument
* no this
* component only with render method
* jsx in jsx

## view/presentation component,

* pure component
	* component without state like functional componet, need to push up the state becaouse application logic need to decide based on it


a presentacios contener is tartalmazhat viselkedest Ã©s adatokat, ha egyszeru
ez altalaban egy pure function

## container component

* fetch data from server

* provide data and behaviours for the presentation components
 ez altalaban egy class



## higher order component


1. pure function
const Todo = ({

}) => (

);

nincs benne this!
pass props in {}

2.class
class Todo extends Component

van this


###############################################################################################################################
# best practices

## Keep your state flat

* normalizer

## immutable states

* immutablejs

## routing

## Code splitting, lazy loading

## components

* use classes
###############################################################################################################################
# performace

## key, value in list items

###############################################################################################################################

# how to create components

## Step 1: break the UI into a component hierarchy

* single responsibility princilple
* often displaying a JSON data model to a user
* dentified the components in our mock, let's arrange them into a hierarchy.

## Step 2: Build a static version

* takes your data model and renders the UI but has no interactivity
	* The components will only haveÂ render()Â methods since this is a static version of your app.
	* PROP

## Step 3: Identify the minimal (but complete) representation of UI state

* DRY:Â Don't Repeat Yourself
* figure out which one is STATE


	•Is it passed in from a parent via props? If so, it probably isn't state.
   Does it change over time? If not, it probably isn't state.
 Can you compute it based on any other state or props in your component? If so, it's not state.

## Step 4: Identify where your state should live

* Next, we need to identify which component mutates, orÂ owns, this state.

	For each piece of state in your application:

		* Identify every component that renders something based on that state.
		* Find a common owner component (a single component above all the components that need the state in the hierarchy).
		* Either the common owner or another component higher up in the hierarchy should own the state.
		* If you can't find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.


	new update

## Step 5: Add inverse data flow

* ReactLinkÂ to make this pattern as convenient as two-way binding


###############################################################################################################################
# flux
Jellemzok:


	* single directional data flow (unidirectional)
	* data consistency easier find a bug, has a direction of flow
	* views query Stores (not Models), and user interactions result in Actions that are submitted to a centralized single Dispatcher.
	* The main difference between MVC and Flux is the separation of queries and updates
	*  In Flux, the data that a View gets from a Store is read-only. Stores can only be updated through Actions, which would affect the Stores themselves not the read-only data.


 .                   ,,,,,,,,,,,,,,,,,,,,,,,.,
 .                   ,,,,,,,,,,,,,,,,,,,,,,,,, ................     .       .
 ................../ ,,,,,,,, ACTIONS ,,,,,,,,, /........      .
 .                   ,,,,,,,,,,,,,,,,,,,,,,,,,        .       .     /
 .                   ,,,,,,,,,,,,,,,,,,,,,,,,,        .       .
 .                               .                    .       .   /
 .                               .                    .       .     /
 .                               /                    .       .     /
 .                   /////////////////////////        .       .     /
 .                   /////////////////////////        .       .     /
 .                   ////DISPATCHER      /////        .       .     /
 .                   /////////////////////////        .       .     /
 .                   ************(***********,        .       .     /
 .                               .                    .       .     /
 .                               .                    .       .     /
 .                               /*                   .       .    /
 .                   *************************        .       .     /
 .                   *********,***************        .       .     /
 .                   ********STORES  *,*********        .       .
 .                   *************************        .       .     /
 .                               .                    .       .     /
 .                               .                    .       .     /
 .                               .                    .       .     #*
 .                               /                    .       /.     .
 .                   (((((((((((((((((((((((((      */.///////./////////////////
 .                   (((((((((/.,(((((((((((((      */.///////.//././,//////////
 .                   ((((((( VIEWS     ((((((((      */./////API    //////////
 ................... (((((((((((((((((((((((((      */.///////./////////////////

Stores:

	* hold data
   • multiples stores
	* signal when something changed
	* emits a change and the views rerendered
   • it is an event emitter
	* Containers for application state & logic that have callbacks registered to the dispatcher
   • every store register to dispacher


Views:

	* subscribe to the store
	* readonly store data!!
	* React Components that grab the state from Stores and pass it down via props to child components
   • action creator function


Actions

	* things that happen
   • action az egy literal payload
	* Helper (action creators) methods that facilitate passing data to the Dispatcher
	* view triggered actions and server/API triggered actions


Dispacher

	* every action passes thouth the dipacther
   • singleton
	* handle actions one by one (queue)
	* to the registered store
	* make sure every Action invokes onDispatch on every Strore
	* Receives actions and broadcasts payloads to registered callbacks
   • notified the stores, if it interested update their notify the views


API:

	* data that is coming from (or going to) the outside



## redux
• no multiple stores
• no Dispacher, instead there will be a dispatch method
• simple store with dispach method
• reducerss

# action creators

### dev how to

#### setup project

* npm init -y
* index.html
* webpack
* babel
* unit test support
	* chai, mocha, jsdom, chai-immutable
	* npm test, npm test:watch
* react-hot-loader

#### UI

* create index.js
* create the first and later second ... bigger react component
	* add fake data as first props (inital data)
		* can see the "static" result without behaviour
	* robust: handle input props with default value
	* create first unit test for functionality, unit test for callbacks
		* can be a rendering test
			* react-addons-test-utils
				* renderIntoDocument
				* scryRenderedDOMComponentsWithTag
		* test callback behaviour, add a props as callback it appers only in init test
			* callback click test etc.
				* Simulate
	* add fake data as second props (change the view of the component )
		* fe: it will disabled
		* rendeered diffrently
		* setup an attriburte a HTML element
		* if statemenst:D
	* add an other second component and can remove previevlis one, for desingned purpose
		* do the same as previlious
		* if else, bloated components
	* refactor
		* create 2 ore more UI component
		* create a common parent for this two
	* test
		* already implement unit test move to parent as the "unit" to test
		* write unit test for the missing "props"
		* inject pros through parent
			* use ref to found them
* pure components
	* PureRenderMixin
		* react-addons-pure-render-mixin
	* use immutable
* routing
	* create main App which inject props temporally

#### desing redux store

* test for reducer
	* implement reducer
* add it to index.js
	* add fake init it it comes from server
* Provide
	* components need to be "wired up"
		* root (App)
		* parent components or/ and routing component (connected/smart component)
			* create container componet (add store for them)
				* use as routing componet
				* can keeep in one module smart comonent
				* now can remove fake datas from root APP
		* leaf component (pure/dumb component)
* init store
	* with real dispacahed action
* add more test for reducers
	* add action to connected componenst
* add action creators

#### add middleware

* disting bettwen remote and local action

### every request is a diffrent store?

