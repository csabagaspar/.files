redux

                                     * * *

## redux
• imutable state tree, has to return a new object no modify
• only pure function
• descrbe state change with action
• no multiple stores
• no Dispacher, instead there will be a dispatch method
• simple store with dispach method

# reducer
   pure function
# store( simple object,input egy reducer, return with functions)
   • dispach()
   • getState()
   • subscribe()
   •
# action creator
   • it might have global state, like a simple counter
   • it is a simple function
   •

# type of components
• presentation (state, action), functional component
• container comp, connect(mapStateToProps, mapDispatchToProps) a mappek egy objectettel ternek vissza
   • lehet van a contenernek propertije, igy a mapState.. es a mapDispatch.. kap egy ownProps-ot a state es a dispatch melle
                                     * * *

### dev how to
# redux react refactor (extracting presentation components)
 1. a bigger component, or more (call root component )
  • with data and behavior
2. refactor it into smaller ones
   • with only props

FE1: comp1 —> TodoList —> Todo
   cont.com -> prez.comp -> prez.comp
   todos ->props.todos —> props.todo
  dispach() onTodoClick —> ()=> onTodoClick(todo.id) —> props.onClick

FE2:
   comp1 —> AddTodo(input comp)
   cont.com —> prez-com
   no data —> no data as input porps
   disapcth action —> props click
SUMMARY:
• all store and callbakc dispach action are in comp1
• all store and calback action  should go minden komponensen at kell menni amig
eler a vegere

# redux refactor (extract container component)

FE1:
   comp1- > VisibleTodoList —> TodoList —> Todo
   ? —>cont, —> prez —> prez

FE2:
   comp1 -> Footer —> FilterLink —> Link
   ?  —> prez.c —> cont.com  —> prez.com
   ?  —> input             —> receive props, from prez, def action callback, and store —>
                pros.callback and data

#### setup project

* create the first and later second ... bigger react component
	* add fake data as first props (inital data)
		* can see the "static" result without behaviour
	* robust: handle input props with default value
	* create first unit test for functionality, unit test for callbacks
		* can be a rendering test
			* react-addons-test-utils
				* renderIntoDocument
				* scryRenderedDOMComponentsWithTag
		* test callback behaviour, add a props as callback it appers only in init test
			* callback click test etc.
				* Simulate
	* add fake data as second props (change the view of the component )
		* fe: it will disabled
		* rendeered diffrently
		* setup an attriburte a HTML element
		* if statemenst:D
	* add an other second component and can remove previevlis one, for desingned purpose
		* do the same as previlious
		* if else, bloated components
	* refactor
		* create 2 ore more UI component
		* create a common parent for this two
	* test
		* already implement unit test move to parent as the "unit" to test
		* write unit test for the missing "props"
		* inject pros through parent
			* use ref to found them
* pure components
	* PureRenderMixin
		* react-addons-pure-render-mixin
	* use immutable
* routing
	* create main App which inject props temporally

#### desing redux store

* test for reducer
	* implement reducer
* add it to index.js
	* add fake init it it comes from server
* Provide
	* components need to be "wired up"
		* root (App)
		* parent components or/ and routing component (connected/smart component)
			* create container componet (add store for them)
				* use as routing componet
				* can keeep in one module smart comonent
				* now can remove fake datas from root APP
		* leaf component (pure/dumb component)
* init store
	* with real dispacahed action
* add more test for reducers
	* add action to connected componenst
* add action creators

#### add middleware

* disting bettwen remote and local action

### every request is a diffrent store?

