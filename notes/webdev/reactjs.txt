reactjs


###############################################################################################################################
# properties

STATE
## initial state
   • es6, in constructor use this.state= {}

* setState
	* is private to the component and can be changed by callingÂ this.setState(). When the state updates, the component re-renders itself.
   • ha csal az egyik tulajdonsagat updatelem a state-nek akkor a tobbi nem valtozik
* mutable
	* setState eseten csak imutable operatorokat hasznalunk, ha az elozobol kell kiindulni
   • ha a state, props valtozik, ujra meghivodik a render

                                     * * *

PROPS
## this.props

  * are immutable
* propTypes
* defaultProps
* children

                                     * * *

## mixins in es5 / higher order component in es6


## statics

## refs
 • controlled input : <input type="text" ref={input => this._name = input} />
  and pull it if needed: handleSubmitClick = () => {
    const name = this._name.value;
    // do something with `name`
  }
  • controlled:.
     ◦ react way: store in state: <input
          type="text"
          value={this.state.name}
          onChange={this.handleNameChange}
        />

## this binding
   •ha van egy event handling, akkor kell a bind
   •handler pass argument with bind

   * do it in constructor in ES6 syntax
      • this.handleAction = this.handleAction.bind(this)
   * in Class sintax?
## event handling(classon kivul kesz a scopja)
      <button onClick = {this.handleAction.bind(this)}> Add </button>

## chilren component
   access child component, refs

## render
   * use null for do nothing or render nothing


###############################################################################################################################
# lifecycle

## shouldComponentUpdate(nextProps, nextState)
• ha egy listaban komponensek vannak, és az egyiket megvaltoztatom (szulo state, valtoztatas) akkor mindegyik a listaban ujrarenderelodik
de ha ezt hasznalom akkot annak a renderje nem fut ujra, ha nem valtozott a state
• minimal logika kell ide hogy ne legyen koltsegesebb mint a render()

## componentDidUpdate

* lefoto function update utan pl: a fokuszt rarakom egy adott elemre
	* this.refs.details.getDOMNode().focus();


###############################################################################################################################

# component types

## functional stateless component

* no return as needed
	* oneliner with () ——>  let MyCom = props => ()
* pass props as argument
* no this
* component only with render method
* jsx in jsx

## view/presentation component,

* pure component
	* component without state like functional componet, need to push up the state becaouse application logic need to decide based on it


a presentacios contener is tartalmazhat viselkedest Ã©s adatokat, ha egyszeru
ez altalaban egy pure function

## container component

* fetch data from server

* provide data and behaviours for the presentation components
 ez altalaban egy class



## higher order component


1. pure function
const Todo = ({

}) => (

);

nincs benne this!
pass props in {}

2.class
class Todo extends Component

van this


###############################################################################################################################
# best practices

## Keep your state flat

* normalizer

## immutable states

* immutablejs

## routing

## Code splitting, lazy loading

## components

* use classes
###############################################################################################################################
# performace

## key, value in list items
## controlled component

###############################################################################################################################

# how to create components

## Step 1: break the UI into a component hierarchy

* single responsibility princilple
* often displaying a JSON data model to a user
* dentified the components in our mock, let's arrange them into a hierarchy.

## Step 2: Build a static version

* takes your data model and renders the UI but has no interactivity
	* The components will only haveÂ render()Â methods since this is a static version of your app.
	* PROP

## Step 3: Identify the minimal (but complete) representation of UI state

* DRY:Â Don't Repeat Yourself
* figure out which one is STATE


	•Is it passed in from a parent via props? If so, it probably isn't state.
   Does it change over time? If not, it probably isn't state.
 Can you compute it based on any other state or props in your component? If so, it's not state.

## Step 4: Identify where your state should live

* Next, we need to identify which component mutates, orÂ owns, this state.

	For each piece of state in your application:

		* Identify every component that renders something based on that state.
		* Find a common owner component (a single component above all the components that need the state in the hierarchy).
		* Either the common owner or another component higher up in the hierarchy should own the state.
		* If you can't find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.


	new update

## Step 5: Add inverse data flow

* ReactLinkÂ to make this pattern as convenient as two-way binding


